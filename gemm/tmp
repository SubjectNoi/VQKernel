8 9
2024-02-02 12:01:19 [INFO] Logging directory: /tmp/tmp6ika3zf5/logs
2024-02-02 12:01:19 [INFO] LocalRunner: max_workers = 1
2024-02-02 12:01:19 [INFO] [task_scheduler.cc:159] Initializing Task #0: "main"
2024-02-02 12:01:20 [INFO] [task_scheduler.cc:320] 
 ID | Name |       FLOP | Weight | Speed (GFLOPS) | Latency (us) | Weighted Latency (us) | Trials | Done 
---------------------------------------------------------------------------------------------------------
  0 | main | 2147483648 |      1 |            N/A |          N/A |                   N/A |      0 |      
---------------------------------------------------------------------------------------------------------
Total trials: 0
Total latency (us): 0

2024-02-02 12:01:20 [INFO] [task_scheduler.cc:180] TaskScheduler picks Task #0: "main"
2024-02-02 12:02:12 [INFO] [task_scheduler.cc:193] Sending 8 sample(s) to builder
2024-02-02 12:02:19 [INFO] [task_scheduler.cc:195] Sending 8 sample(s) to runner
2024-02-02 12:02:23 [DEBUG] XGB iter   0: tr-p-rmse: 0.440884	tr-a-peak@32: 1.000000	tr-rmse: 0.468384	tr-rmse: 0.468384
2024-02-02 12:02:23 [DEBUG] XGB iter  25: tr-p-rmse: 0.015402	tr-a-peak@32: 1.000000	tr-rmse: 0.543889	tr-rmse: 0.543889
2024-02-02 12:02:23 [DEBUG] XGB iter  50: tr-p-rmse: 0.015402	tr-a-peak@32: 1.000000	tr-rmse: 0.543889	tr-rmse: 0.543889
2024-02-02 12:02:24 [DEBUG] XGB stopped. Best iteration: [18] tr-p-rmse:0.01540	tr-a-peak@32:1.00000	tr-rmse:0.54389	tr-rmse:0.54389 
2024-02-02 12:02:24 [INFO] [task_scheduler.cc:237] [Updated] Task #0: "main"
2024-02-02 12:02:24 [INFO] [task_scheduler.cc:320] 
 ID | Name |       FLOP | Weight | Speed (GFLOPS) | Latency (us) | Weighted Latency (us) | Trials | Done 
---------------------------------------------------------------------------------------------------------
  0 | main | 2147483648 |      1 |     41632.4393 |      51.5820 |               51.5820 |      8 |      
---------------------------------------------------------------------------------------------------------
Total trials: 8
Total latency (us): 51.582

2024-02-02 12:02:24 [INFO] [task_scheduler.cc:260] Task #0 has finished. Remaining task(s): 0
2024-02-02 12:02:24 [INFO] [task_scheduler.cc:320] 
 ID | Name |       FLOP | Weight | Speed (GFLOPS) | Latency (us) | Weighted Latency (us) | Trials | Done 
---------------------------------------------------------------------------------------------------------
  0 | main | 2147483648 |      1 |     41632.4393 |      51.5820 |               51.5820 |      8 |    Y 
---------------------------------------------------------------------------------------------------------
Total trials: 8
Total latency (us): 51.582

#if defined(__CUDA_ARCH__) && (__CUDA_ARCH__ >= 530)
#include <cuda_fp16.h>
__device__ half max(half a, half b)
{
  return __hgt(__half(a), __half(b)) ? a : b;
}
__device__ half min(half a, half b)
{
  return __hlt(__half(a), __half(b)) ? a : b;
}
#else

typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef signed char int8_t;
typedef int int32_t;
typedef unsigned long long uint64_t;
typedef unsigned int uint32_t;

#define TVM_FORCE_INLINE inline __attribute__((always_inline))
#define TVM_XINLINE TVM_FORCE_INLINE __device__ __host__
#define TVM_ALIGNED(x) __attribute__ ((aligned(x)))
#define TVM_HALF_OPERATOR(RTYPE, OP)                              \
  TVM_XINLINE RTYPE operator OP (half a, half b) {                \
    return RTYPE(float(a) OP float(b));                           \
  }                                                               \
  template<typename T>                                            \
  TVM_XINLINE RTYPE operator OP (half a, T b) {                   \
    return RTYPE(float(a) OP float(b));                           \
  }                                                               \
  template<typename T>                                            \
  TVM_XINLINE RTYPE operator OP (T a, half b) {                   \
    return RTYPE(float(a) OP float(b));                           \
  }

#define TVM_HALF_ASSIGNOP(AOP, OP)                                \
  template<typename T>                                            \
  TVM_XINLINE half operator AOP (const T& a) {                    \
    return *this = half(float(*this) OP float(a));                \
  }                                                               \
  template<typename T>                                            \
  TVM_XINLINE half operator AOP (const volatile T& a) volatile {  \
    return *this = half(float(*this) OP float(a));                \
  }

class TVM_ALIGNED(2) half {
 public:
  uint16_t half_;

  static TVM_XINLINE half Binary(uint16_t value) {
    half res;
    res.half_ = value;
    return res;
  }

  TVM_XINLINE half() {}

  TVM_XINLINE half(const float& value) { constructor(value); }
  TVM_XINLINE explicit half(const double& value) { constructor(value); }
  TVM_XINLINE explicit half(const int8_t& value) { constructor(value); }
  TVM_XINLINE explicit half(const uint8_t& value) { constructor(value); }
  TVM_XINLINE explicit half(const int32_t& value) { constructor(value); }
  TVM_XINLINE explicit half(const uint32_t& value) { constructor(value); }
  TVM_XINLINE explicit half(const long long& value) { constructor(value); }
  TVM_XINLINE explicit half(const uint64_t& value) { constructor(value); }

  TVM_XINLINE operator float() const {                          \
    return float(half2float(half_));                            \
  }                                                             \
  TVM_XINLINE operator float() const volatile {                 \
    return float(half2float(half_));                            \
  }


  TVM_HALF_ASSIGNOP(+=, +)
  TVM_HALF_ASSIGNOP(-=, -)
  TVM_HALF_ASSIGNOP(*=, *)
  TVM_HALF_ASSIGNOP(/=, /)

  TVM_XINLINE half operator+() {
    return *this;
  }

  TVM_XINLINE half operator-() {
    return half(-float(*this));
  }

  TVM_XINLINE half operator=(const half& a) {
    half_ = a.half_;
    return a;
  }

  template<typename T>
  TVM_XINLINE half operator=(const T& a) {
    return *this = half(a);
  }

  TVM_XINLINE half operator=(const half& a) volatile {
    half_ = a.half_;
    return a;
  }

  template<typename T>
  TVM_XINLINE half operator=(const T& a) volatile {
    return *this = half(a);
  }

 private:
  union Bits {
    float f;
    int32_t si;
    uint32_t ui;
  };

  static int const fp16FractionBits = 10;
  static int const fp32FractionBits = 23;
  static int32_t const fp32FractionMask = ~(~0u << fp32FractionBits);   // == 0x7fffff
  static int32_t const fp32HiddenBit = 1 << fp32FractionBits;   // == 0x800000
  static int const shift = fp32FractionBits - fp16FractionBits;   // == 13
  static int const shiftSign = 16;
  static int32_t const expAdjust = 127 - 15;   // exp32-127 = exp16-15, so exp16 = exp32 - (127-15)

  static int32_t const infN = 0x7F800000;   // flt32 infinity
  static int32_t const maxN = 0x477FFFFF;   // max flt32 that's a flt16 normal after >> by shift
  static int32_t const minN = 0x38800000;   // min flt16 normal as a flt32
  static int32_t const maxZ = 0x33000000;   // max fp32 number that's still rounded to zero in fp16
  static int32_t const signN = 0x80000000;  // flt32 sign bit

  static int32_t const infC = infN >> shift;
  static int32_t const nanN = (infC + 1) << shift;   // minimum flt16 nan as a flt32
  static int32_t const maxC = maxN >> shift;
  static int32_t const minC = minN >> shift;
  static int32_t const signC = signN >> shiftSign;  // flt16 sign bit

  static int32_t const mulN = 0x52000000;  // (1 << 23) / minN
  static int32_t const mulC = 0x33800000;  // minN / (1 << (23 - shift))

  static int32_t const subC = 0x003FF;  // max flt32 subnormal down shifted
  static int32_t const norC = 0x00400;  // min flt32 normal down shifted

  static int32_t const maxD = infC - maxC - 1;
  static int32_t const minD = minC - subC - 1;

  TVM_XINLINE uint16_t float2half(const float& value) const {
    Bits v;
    v.f = value;
    uint32_t sign = v.si & signN;    // grab sign bit
    v.si ^= sign;                    // clear sign bit from v
    sign >>= shiftSign;              // logical shift sign to fp16 position

    if (v.si <= maxZ) {
      // Handle eventual zeros here to ensure
      // vshift will not exceed 32 below.
      v.ui = 0;
    } else if (v.si < minN) {
      // Handle denorms
      uint32_t exp32 = v.ui >> fp32FractionBits;
      int32_t exp16 = exp32 - expAdjust;
      // If exp16 == 0 (just into the denorm range), then significant should be shifted right 1.
      // Smaller (so negative) exp16 values should result in greater right shifts.
      uint32_t vshift = 1 - exp16;
      uint32_t significand = fp32HiddenBit | (v.ui & fp32FractionMask);
      v.ui = significand >> vshift;
      v.ui += (v.ui & 0x3fff) != 0x1000 || (significand & 0x7ff) ? 0x1000 : 0;
    } else if (v.si <= maxN) {
      // Handle norms
      v.ui += (v.ui & 0x3fff) != 0x1000 ? 0x1000 : 0;
      v.ui -= expAdjust << fp32FractionBits;
    } else if (v.si <= infN) {
      v.si = infN;
    } else if (v.si < nanN) {
      v.si = nanN;
    }

    v.ui >>= shift;
    return sign | (v.ui & 0x7fff);
  }

  // Same as above routine, except for addition of volatile keyword
  TVM_XINLINE uint16_t float2half(
    const volatile float& value) const volatile {
    Bits v;
    v.f = value;
    uint32_t sign = v.si & signN;    // grab sign bit
    v.si ^= sign;                    // clear sign bit from v
    sign >>= shiftSign;              // logical shift sign to fp16 position

    if (v.si <= maxZ) {
      // Handle eventual zeros here to ensure
      // vshift will not exceed 32 below.
      v.ui = 0;
    } else if (v.si < minN) {
      // Handle denorms
      uint32_t exp32 = v.ui >> fp32FractionBits;
      int32_t exp16 = exp32 - expAdjust;
      // If exp16 == 0 (just into the denorm range), then significant should be shifted right 1.
      // Smaller (so negative) exp16 values should result in greater right shifts.
      uint32_t vshift = 1 - exp16;
      uint32_t significand = fp32HiddenBit | (v.ui & fp32FractionMask);
      v.ui = significand >> vshift;
      v.ui += (v.ui & 0x3fff) != 0x1000 || (significand & 0x7ff) ? 0x1000 : 0;
    } else if (v.si <= maxN) {
      // Handle norms
      v.ui += (v.ui & 0x3fff) != 0x1000 ? 0x1000 : 0;
      v.ui -= expAdjust << fp32FractionBits;
    } else if (v.si <= infN) {
      v.si = infN;
    } else if (v.si < nanN) {
      v.si = nanN;
    }

    v.ui >>= shift;
    return sign | (v.ui & 0x7fff);
  }

  TVM_XINLINE float half2float(const uint16_t& value) const {
    Bits v;
    v.ui = value;
    int32_t sign = v.si & signC;
    v.si ^= sign;
    sign <<= shiftSign;
    v.si ^= ((v.si + minD) ^ v.si) & -(v.si > subC);
    v.si ^= ((v.si + maxD) ^ v.si) & -(v.si > maxC);
    Bits s;
    s.si = mulC;
    s.f *= v.si;
    int32_t mask = -(norC > v.si);
    v.si <<= shift;
    v.si ^= (s.si ^ v.si) & mask;
    v.si |= sign;
    return v.f;
  }

  TVM_XINLINE float half2float(
    const volatile uint16_t& value) const volatile {
    Bits v;
    v.ui = value;
    int32_t sign = v.si & signC;
    v.si ^= sign;
    sign <<= shiftSign;
    v.si ^= ((v.si + minD) ^ v.si) & -(v.si > subC);
    v.si ^= ((v.si + maxD) ^ v.si) & -(v.si > maxC);
    Bits s;
    s.si = mulC;
    s.f *= v.si;
    int32_t mask = -(norC > v.si);
    v.si <<= shift;
    v.si ^= (s.si ^ v.si) & mask;
    v.si |= sign;
    return v.f;
  }

  template<typename T>
  TVM_XINLINE void constructor(const T& value) {
    half_ = float2half(float(value));
  }
};

TVM_HALF_OPERATOR(half, +)
TVM_HALF_OPERATOR(half, -)
TVM_HALF_OPERATOR(half, *)
TVM_HALF_OPERATOR(half, /)
TVM_HALF_OPERATOR(bool, >)
TVM_HALF_OPERATOR(bool, <)
TVM_HALF_OPERATOR(bool, >=)
TVM_HALF_OPERATOR(bool, <=)

TVM_XINLINE half __float2half_rn(const float a) {
  return half(a);
}
#endif


// Pack two half values.
static inline __device__ __host__ unsigned
__pack_half2(const half x, const half y) {
  unsigned v0 = *((unsigned short *)&x);
  unsigned v1 = *((unsigned short *)&y);
  return (v1 << 16) | v0;
}

#define CUDA_UNSUPPORTED_HALF_MATH_BINARY(HALF_MATH_NAME, FP32_MATH_NAME) \
static inline __device__ __host__ half HALF_MATH_NAME(half x, half y) {   \
  float tmp_x = __half2float(x);                                          \
  float tmp_y = __half2float(y);                                          \
  float result = FP32_MATH_NAME(tmp_x, tmp_y);                            \
  return __float2half(result);                                            \
}

#define CUDA_UNSUPPORTED_HALF_MATH_UNARY(HALF_MATH_NAME, FP32_MATH_NAME) \
static inline __device__ __host__ half HALF_MATH_NAME(half x) {          \
  float tmp_x = __half2float(x);                                         \
  float result = FP32_MATH_NAME(tmp_x);                                  \
  return __float2half(result);                                           \
}

// Some fp16 math functions are not supported in cuda_fp16.h,
// so we define them here to make sure the generated CUDA code
// is valid.
#if defined(__CUDA_ARCH__)
#if (__CUDA_ARCH__ >= 530)
CUDA_UNSUPPORTED_HALF_MATH_BINARY(hpow, powf)
CUDA_UNSUPPORTED_HALF_MATH_UNARY(htanh, tanhf)
CUDA_UNSUPPORTED_HALF_MATH_UNARY(htan, tanf)
CUDA_UNSUPPORTED_HALF_MATH_UNARY(hatan, atanf)
CUDA_UNSUPPORTED_HALF_MATH_UNARY(herf, erf)
#else
CUDA_UNSUPPORTED_HALF_MATH_UNARY(hexp, exp)
#endif
#endif

#undef CUDA_UNSUPPORTED_HALF_MATH_BINARY
#undef CUDA_UNSUPPORTED_HALF_MATH_UNARY
#if defined(__CUDA_ARCH__) && (__CUDA_ARCH__ >= 610)
#include <sm_61_intrinsics.h>


#if defined(__CUDACC_RTC__)
#define __SM_61_INTRINSICS_DECL__ __device__
#else /* !__CUDACC_RTC__ */
#define __SM_61_INTRINSICS_DECL__ static __device__ __inline__
#endif /* __CUDACC_RTC__ */

#ifndef __CUDA_ARCH__
#define __DEF_IF_HOST { }
#else  /* !__CUDA_ARCH__ */
#define __DEF_IF_HOST ;
#endif /* __CUDA_ARCH__ */

__SM_61_INTRINSICS_DECL__ int __dp4a(unsigned int srcA, int srcB, int c) __DEF_IF_HOST
__SM_61_INTRINSICS_DECL__ int __dp4a(int srcA, unsigned int srcB, int c) __DEF_IF_HOST

#undef __DEF_IF_HOST

#if !defined(__CUDACC_RTC__) && defined(__CUDA_ARCH__)
__SM_61_INTRINSICS_DECL__ int __dp4a(unsigned int srcA, int srcB, int c) {
    int ret;
    asm volatile ("dp4a.u32.s32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}

__SM_61_INTRINSICS_DECL__ int __dp4a(int srcA, unsigned int srcB, int c) {
    int ret;
    asm volatile ("dp4a.s32.u32 %0, %1, %2, %3;" : "=r"(ret) : "r"(srcA), "r"(srcB), "r"(c));
    return ret;
}
#endif /* !__CUDACC_RTC__ && defined(__CUDA_ARCH__) */

#undef __SM_61_INTRINSICS_DECL__

#endif
#include <mma.h>

#if (((__CUDACC_VER_MAJOR__ == 11) && (__CUDACC_VER_MINOR__ >= 4)) || \
     (__CUDACC_VER_MAJOR__ > 11))
#define TVM_ENABLE_L2_PREFETCH 1
#else
#define TVM_ENABLE_L2_PREFETCH 0
#endif

#ifdef _WIN32
  using uint = unsigned int;
  using uchar = unsigned char;
  using ushort = unsigned short;
  using int64_t = long long;
  using uint64_t = unsigned long long;
#else
  #define uint unsigned int
  #define uchar unsigned char
  #define ushort unsigned short
  #define int64_t long long
  #define uint64_t unsigned long long
#endif
extern "C" __global__ void __launch_bounds__(64) main_kernel(uchar* __restrict__ A, uchar* __restrict__ B, half* __restrict__ C, half* __restrict__ CA, half* __restrict__ CB);
extern "C" __global__ void __launch_bounds__(64) main_kernel(uchar* __restrict__ A, uchar* __restrict__ B, half* __restrict__ C, half* __restrict__ CA, half* __restrict__ CB) {
  extern __shared__ uchar buf_dyn_shmem[];
  nvcuda::wmma::fragment<nvcuda::wmma::accumulator, 16, 16, 16, half> C_reindex_shared_dyn_wmma_accumulator[8];
  nvcuda::wmma::fragment<nvcuda::wmma::matrix_a, 16, 16, 16, half, nvcuda::wmma::row_major> A__reindex_shared_dyn_wmma_matrix_a[2];
  nvcuda::wmma::fragment<nvcuda::wmma::matrix_b, 16, 16, 16, half, nvcuda::wmma::row_major> B__reindex_shared_dyn_wmma_matrix_b[4];
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[0], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[1], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[4], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[5], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[2], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[3], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[6], 0.000000e+00f);
  nvcuda::wmma::fill_fragment(C_reindex_shared_dyn_wmma_accumulator[7], 0.000000e+00f);
  for (int ax2_0_0 = 0; ax2_0_0 < 64; ++ax2_0_0) {
    __syncthreads();
    int4 __1;
      int4 __2;
        int4 __3;
        int4 __4;
          int4 v_ = make_int4((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)), (((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)), (((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)), (((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)));
          int4 __5;
            int4 v__1 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
            int4 v__2 = make_int4(2, 2, 2, 2);
            __5.x = (v__1.x/v__2.x);
            __5.y = (v__1.y/v__2.y);
            __5.z = (v__1.z/v__2.z);
            __5.w = (v__1.w/v__2.w);
          __4.x = (v_.x+__5.x);
          __4.y = (v_.y+__5.y);
          __4.z = (v_.z+__5.z);
          __4.w = (v_.w+__5.w);
        uint v__3 = ((0x000000ff << 0) & (A[__4.x] << 0))|((0x000000ff << 8) & (A[__4.y] << 8))|((0x000000ff << 16) & (A[__4.z] << 16))|((0x000000ff << 24) & (A[__4.w] << 24));
        __3.x = (int)(((unsigned char)(v__3 >> 0)));
        __3.y = (int)(((unsigned char)(v__3 >> 8)));
        __3.z = (int)(((unsigned char)(v__3 >> 16)));
        __3.w = (int)(((unsigned char)(v__3 >> 24)));
        int4 v__4 = make_int4(1024, 1024, 1024, 1024);
        __2.x = (__3.x*v__4.x);
        __2.y = (__3.y*v__4.y);
        __2.z = (__3.z*v__4.z);
        __2.w = (__3.w*v__4.w);
      int4 __6;
        int4 v__5 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
        int4 v__6 = make_int4(2, 2, 2, 2);
        __6.x = (v__5.x%v__6.x);
        __6.y = (v__5.y%v__6.y);
        __6.z = (v__5.z%v__6.z);
        __6.w = (v__5.w%v__6.w);
      __1.x = (__2.x+__6.x);
      __1.y = (__2.y+__6.y);
      __1.z = (__2.z+__6.z);
      __1.w = (__2.w+__6.w);
    *(uint2*)(((half*)buf_dyn_shmem) + ((((((int)threadIdx.y) * 320) + ((((int)threadIdx.x) >> 2) * 40)) + ((((int)threadIdx.x) & 3) * 4)) + 1152)) = make_uint2(__pack_half2(CA[__1.x],CA[__1.y]),__pack_half2(CA[__1.z],CA[__1.w]));
    int4 __7;
      int4 __8;
        int4 __9;
        int4 __10;
          int4 v__7 = make_int4(((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 512), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 512), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 512), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 512));
          int4 __11;
            int4 v__8 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
            int4 v__9 = make_int4(2, 2, 2, 2);
            __11.x = (v__8.x/v__9.x);
            __11.y = (v__8.y/v__9.y);
            __11.z = (v__8.z/v__9.z);
            __11.w = (v__8.w/v__9.w);
          __10.x = (v__7.x+__11.x);
          __10.y = (v__7.y+__11.y);
          __10.z = (v__7.z+__11.z);
          __10.w = (v__7.w+__11.w);
        uint v__10 = ((0x000000ff << 0) & (A[__10.x] << 0))|((0x000000ff << 8) & (A[__10.y] << 8))|((0x000000ff << 16) & (A[__10.z] << 16))|((0x000000ff << 24) & (A[__10.w] << 24));
        __9.x = (int)(((unsigned char)(v__10 >> 0)));
        __9.y = (int)(((unsigned char)(v__10 >> 8)));
        __9.z = (int)(((unsigned char)(v__10 >> 16)));
        __9.w = (int)(((unsigned char)(v__10 >> 24)));
        int4 v__11 = make_int4(1024, 1024, 1024, 1024);
        __8.x = (__9.x*v__11.x);
        __8.y = (__9.y*v__11.y);
        __8.z = (__9.z*v__11.z);
        __8.w = (__9.w*v__11.w);
      int4 __12;
        int4 v__12 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
        int4 v__13 = make_int4(2, 2, 2, 2);
        __12.x = (v__12.x%v__13.x);
        __12.y = (v__12.y%v__13.y);
        __12.z = (v__12.z%v__13.z);
        __12.w = (v__12.w%v__13.w);
      __7.x = (__8.x+__12.x);
      __7.y = (__8.y+__12.y);
      __7.z = (__8.z+__12.z);
      __7.w = (__8.w+__12.w);
    *(uint2*)(((half*)buf_dyn_shmem) + ((((((int)threadIdx.y) * 320) + ((((int)threadIdx.x) >> 2) * 40)) + ((((int)threadIdx.x) & 3) * 4)) + 1792)) = make_uint2(__pack_half2(CA[__7.x],CA[__7.y]),__pack_half2(CA[__7.z],CA[__7.w]));
    int4 __13;
      int4 __14;
        int4 __15;
        int4 __16;
          int4 v__14 = make_int4(((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1024), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1024), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1024), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1024));
          int4 __17;
            int4 v__15 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
            int4 v__16 = make_int4(2, 2, 2, 2);
            __17.x = (v__15.x/v__16.x);
            __17.y = (v__15.y/v__16.y);
            __17.z = (v__15.z/v__16.z);
            __17.w = (v__15.w/v__16.w);
          __16.x = (v__14.x+__17.x);
          __16.y = (v__14.y+__17.y);
          __16.z = (v__14.z+__17.z);
          __16.w = (v__14.w+__17.w);
        uint v__17 = ((0x000000ff << 0) & (A[__16.x] << 0))|((0x000000ff << 8) & (A[__16.y] << 8))|((0x000000ff << 16) & (A[__16.z] << 16))|((0x000000ff << 24) & (A[__16.w] << 24));
        __15.x = (int)(((unsigned char)(v__17 >> 0)));
        __15.y = (int)(((unsigned char)(v__17 >> 8)));
        __15.z = (int)(((unsigned char)(v__17 >> 16)));
        __15.w = (int)(((unsigned char)(v__17 >> 24)));
        int4 v__18 = make_int4(1024, 1024, 1024, 1024);
        __14.x = (__15.x*v__18.x);
        __14.y = (__15.y*v__18.y);
        __14.z = (__15.z*v__18.z);
        __14.w = (__15.w*v__18.w);
      int4 __18;
        int4 v__19 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
        int4 v__20 = make_int4(2, 2, 2, 2);
        __18.x = (v__19.x%v__20.x);
        __18.y = (v__19.y%v__20.y);
        __18.z = (v__19.z%v__20.z);
        __18.w = (v__19.w%v__20.w);
      __13.x = (__14.x+__18.x);
      __13.y = (__14.y+__18.y);
      __13.z = (__14.z+__18.z);
      __13.w = (__14.w+__18.w);
    *(uint2*)(((half*)buf_dyn_shmem) + ((((((int)threadIdx.y) * 320) + ((((int)threadIdx.x) >> 2) * 40)) + ((((int)threadIdx.x) & 3) * 4)) + 2432)) = make_uint2(__pack_half2(CA[__13.x],CA[__13.y]),__pack_half2(CA[__13.z],CA[__13.w]));
    int4 __19;
      int4 __20;
        int4 __21;
        int4 __22;
          int4 v__21 = make_int4(((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1536), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1536), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1536), ((((((((((int)blockIdx.x) >> 1) * 32768) + ((ax2_0_0 >> 2) * 2048)) + (((int)threadIdx.y) * 256)) + ((((int)threadIdx.x) >> 2) * 32)) + ((ax2_0_0 & 3) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + 1536));
          int4 __23;
            int4 v__22 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
            int4 v__23 = make_int4(2, 2, 2, 2);
            __23.x = (v__22.x/v__23.x);
            __23.y = (v__22.y/v__23.y);
            __23.z = (v__22.z/v__23.z);
            __23.w = (v__22.w/v__23.w);
          __22.x = (v__21.x+__23.x);
          __22.y = (v__21.y+__23.y);
          __22.z = (v__21.z+__23.z);
          __22.w = (v__21.w+__23.w);
        uint v__24 = ((0x000000ff << 0) & (A[__22.x] << 0))|((0x000000ff << 8) & (A[__22.y] << 8))|((0x000000ff << 16) & (A[__22.z] << 16))|((0x000000ff << 24) & (A[__22.w] << 24));
        __21.x = (int)(((unsigned char)(v__24 >> 0)));
        __21.y = (int)(((unsigned char)(v__24 >> 8)));
        __21.z = (int)(((unsigned char)(v__24 >> 16)));
        __21.w = (int)(((unsigned char)(v__24 >> 24)));
        int4 v__25 = make_int4(1024, 1024, 1024, 1024);
        __20.x = (__21.x*v__25.x);
        __20.y = (__21.y*v__25.y);
        __20.z = (__21.z*v__25.z);
        __20.w = (__21.w*v__25.w);
      int4 __24;
        int4 v__26 = make_int4((0)+(1*0), (0)+(1*1), (0)+(1*2), (0)+(1*3));
        int4 v__27 = make_int4(2, 2, 2, 2);
        __24.x = (v__26.x%v__27.x);
        __24.y = (v__26.y%v__27.y);
        __24.z = (v__26.z%v__27.z);
        __24.w = (v__26.w%v__27.w);
      __19.x = (__20.x+__24.x);
      __19.y = (__20.y+__24.y);
      __19.z = (__20.z+__24.z);
      __19.w = (__20.w+__24.w);
    *(uint2*)(((half*)buf_dyn_shmem) + ((((((int)threadIdx.y) * 320) + ((((int)threadIdx.x) >> 2) * 40)) + ((((int)threadIdx.x) & 3) * 4)) + 3072)) = make_uint2(__pack_half2(CA[__19.x],CA[__19.y]),__pack_half2(CA[__19.z],CA[__19.w]));
    int2 __25;
      int2 __26;
        int2 __27;
        uchar2 v__28 = *(uchar2*)(B + ((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)));
        __27.x = (int)(v__28.x);
        __27.y = (int)(v__28.y);
        int2 v__29 = make_int2(1024, 1024);
        __26.x = (__27.x*v__29.x);
        __26.y = (__27.y*v__29.y);
      int2 v__30 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __25.x = (__26.x+v__30.x);
      __25.y = (__26.y+v__30.y);
    *(uint1*)(((half*)buf_dyn_shmem) + ((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2))) = make_uint1(__pack_half2(CB[__25.x],CB[__25.y]));
    int2 __28;
      int2 __29;
        int2 __30;
        uchar2 v__31 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 64));
        __30.x = (int)(v__31.x);
        __30.y = (int)(v__31.y);
        int2 v__32 = make_int2(1024, 1024);
        __29.x = (__30.x*v__32.x);
        __29.y = (__30.y*v__32.y);
      int2 v__33 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __28.x = (__29.x+v__33.x);
      __28.y = (__29.y+v__33.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 144)) = make_uint1(__pack_half2(CB[__28.x],CB[__28.y]));
    int2 __31;
      int2 __32;
        int2 __33;
        uchar2 v__34 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 128));
        __33.x = (int)(v__34.x);
        __33.y = (int)(v__34.y);
        int2 v__35 = make_int2(1024, 1024);
        __32.x = (__33.x*v__35.x);
        __32.y = (__33.y*v__35.y);
      int2 v__36 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __31.x = (__32.x+v__36.x);
      __31.y = (__32.y+v__36.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 288)) = make_uint1(__pack_half2(CB[__31.x],CB[__31.y]));
    int2 __34;
      int2 __35;
        int2 __36;
        uchar2 v__37 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 192));
        __36.x = (int)(v__37.x);
        __36.y = (int)(v__37.y);
        int2 v__38 = make_int2(1024, 1024);
        __35.x = (__36.x*v__38.x);
        __35.y = (__36.y*v__38.y);
      int2 v__39 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __34.x = (__35.x+v__39.x);
      __34.y = (__35.y+v__39.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 432)) = make_uint1(__pack_half2(CB[__34.x],CB[__34.y]));
    int2 __37;
      int2 __38;
        int2 __39;
        uchar2 v__40 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 256));
        __39.x = (int)(v__40.x);
        __39.y = (int)(v__40.y);
        int2 v__41 = make_int2(1024, 1024);
        __38.x = (__39.x*v__41.x);
        __38.y = (__39.y*v__41.y);
      int2 v__42 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __37.x = (__38.x+v__42.x);
      __37.y = (__38.y+v__42.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 576)) = make_uint1(__pack_half2(CB[__37.x],CB[__37.y]));
    int2 __40;
      int2 __41;
        int2 __42;
        uchar2 v__43 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 320));
        __42.x = (int)(v__43.x);
        __42.y = (int)(v__43.y);
        int2 v__44 = make_int2(1024, 1024);
        __41.x = (__42.x*v__44.x);
        __41.y = (__42.y*v__44.y);
      int2 v__45 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __40.x = (__41.x+v__45.x);
      __40.y = (__41.y+v__45.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 720)) = make_uint1(__pack_half2(CB[__40.x],CB[__40.y]));
    int2 __43;
      int2 __44;
        int2 __45;
        uchar2 v__46 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 384));
        __45.x = (int)(v__46.x);
        __45.y = (int)(v__46.y);
        int2 v__47 = make_int2(1024, 1024);
        __44.x = (__45.x*v__47.x);
        __44.y = (__45.y*v__47.y);
      int2 v__48 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __43.x = (__44.x+v__48.x);
      __43.y = (__44.y+v__48.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 864)) = make_uint1(__pack_half2(CB[__43.x],CB[__43.y]));
    int2 __46;
      int2 __47;
        int2 __48;
        uchar2 v__49 = *(uchar2*)(B + (((((((ax2_0_0 >> 2) * 32768) + (((int)blockIdx.y) * 4096)) + ((((int)blockIdx.x) & 1) * 2048)) + ((ax2_0_0 & 3) * 512)) + (((int)threadIdx.x) * 2)) + 448));
        __48.x = (int)(v__49.x);
        __48.y = (int)(v__49.y);
        int2 v__50 = make_int2(1024, 1024);
        __47.x = (__48.x*v__50.x);
        __47.y = (__48.y*v__50.y);
      int2 v__51 = make_int2(((int)threadIdx.y), ((int)threadIdx.y));
      __46.x = (__47.x+v__51.x);
      __46.y = (__47.y+v__51.y);
    *(uint1*)(((half*)buf_dyn_shmem) + (((((int)threadIdx.y) * 72) + (((int)threadIdx.x) * 2)) + 1008)) = make_uint1(__pack_half2(CB[__46.x],CB[__46.y]));
    __syncthreads();
    nvcuda::wmma::load_matrix_sync(A__reindex_shared_dyn_wmma_matrix_a[0], (&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1280) + 1152)])), 40);
    nvcuda::wmma::load_matrix_sync(A__reindex_shared_dyn_wmma_matrix_a[1], (&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1280) + 1792)])), 40);
    nvcuda::wmma::load_matrix_sync(B__reindex_shared_dyn_wmma_matrix_b[0], (&(((half*)buf_dyn_shmem)[0])), 72);
    nvcuda::wmma::load_matrix_sync(B__reindex_shared_dyn_wmma_matrix_b[1], (&(((half*)buf_dyn_shmem)[16])), 72);
    nvcuda::wmma::load_matrix_sync(B__reindex_shared_dyn_wmma_matrix_b[2], (&(((half*)buf_dyn_shmem)[32])), 72);
    nvcuda::wmma::load_matrix_sync(B__reindex_shared_dyn_wmma_matrix_b[3], (&(((half*)buf_dyn_shmem)[48])), 72);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[0], A__reindex_shared_dyn_wmma_matrix_a[0], B__reindex_shared_dyn_wmma_matrix_b[0], C_reindex_shared_dyn_wmma_accumulator[0]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[1], A__reindex_shared_dyn_wmma_matrix_a[0], B__reindex_shared_dyn_wmma_matrix_b[1], C_reindex_shared_dyn_wmma_accumulator[1]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[4], A__reindex_shared_dyn_wmma_matrix_a[1], B__reindex_shared_dyn_wmma_matrix_b[0], C_reindex_shared_dyn_wmma_accumulator[4]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[5], A__reindex_shared_dyn_wmma_matrix_a[1], B__reindex_shared_dyn_wmma_matrix_b[1], C_reindex_shared_dyn_wmma_accumulator[5]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[2], A__reindex_shared_dyn_wmma_matrix_a[0], B__reindex_shared_dyn_wmma_matrix_b[2], C_reindex_shared_dyn_wmma_accumulator[2]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[3], A__reindex_shared_dyn_wmma_matrix_a[0], B__reindex_shared_dyn_wmma_matrix_b[3], C_reindex_shared_dyn_wmma_accumulator[3]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[6], A__reindex_shared_dyn_wmma_matrix_a[1], B__reindex_shared_dyn_wmma_matrix_b[2], C_reindex_shared_dyn_wmma_accumulator[6]);
    nvcuda::wmma::mma_sync(C_reindex_shared_dyn_wmma_accumulator[7], A__reindex_shared_dyn_wmma_matrix_a[1], B__reindex_shared_dyn_wmma_matrix_b[3], C_reindex_shared_dyn_wmma_accumulator[7]);
  }
  __syncthreads();
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1152)])), C_reindex_shared_dyn_wmma_accumulator[0], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1408)])), C_reindex_shared_dyn_wmma_accumulator[1], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1664)])), C_reindex_shared_dyn_wmma_accumulator[2], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1920)])), C_reindex_shared_dyn_wmma_accumulator[3], 16, nvcuda::wmma::mem_row_major);
  __syncthreads();
  C[(((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15))] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1152)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 256)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1216)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 512)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1280)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 768)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1344)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 16)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1408)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 272)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1472)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 528)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1536)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 784)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1600)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 32)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1664)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 288)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1728)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 544)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1792)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 800)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1856)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 48)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1920)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 304)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1984)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 560)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2048)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 816)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2112)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2048)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2176)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2304)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2240)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2560)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2304)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2816)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2368)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2064)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2432)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2320)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2496)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2576)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2560)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2832)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2624)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2080)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2688)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2336)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2752)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2592)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2816)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2848)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2880)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2096)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2944)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2352)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3008)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2608)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3072)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 2864)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3136)];
  __syncthreads();
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1152)])), C_reindex_shared_dyn_wmma_accumulator[4], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1408)])), C_reindex_shared_dyn_wmma_accumulator[5], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1664)])), C_reindex_shared_dyn_wmma_accumulator[6], 16, nvcuda::wmma::mem_row_major);
  nvcuda::wmma::store_matrix_sync((&(((half*)buf_dyn_shmem)[((((int)threadIdx.y) * 1024) + 1920)])), C_reindex_shared_dyn_wmma_accumulator[7], 16, nvcuda::wmma::mem_row_major);
  __syncthreads();
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1024)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1152)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1280)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1216)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1536)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1280)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1792)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1344)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1040)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1408)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1296)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1472)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1552)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1536)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1808)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1600)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1056)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1664)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1312)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1728)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1568)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1792)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1824)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1856)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1072)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1920)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1328)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 1984)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1584)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2048)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 1840)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2112)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3072)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2176)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3328)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2240)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3584)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2304)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3840)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2368)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3088)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2432)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3344)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2496)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3600)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2560)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3856)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2624)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3104)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2688)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3360)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2752)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3616)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2816)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3872)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2880)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3120)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 2944)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3376)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3008)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3632)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3072)];
  C[((((((((((int)blockIdx.x) >> 1) * 65536) + (((int)blockIdx.y) * 8192)) + ((((int)blockIdx.x) & 1) * 4096)) + (((int)threadIdx.y) * 128)) + ((((int)threadIdx.x) >> 4) * 64)) + (((int)threadIdx.x) & 15)) + 3888)] = ((half*)buf_dyn_shmem)[(((((int)threadIdx.y) * 32) + ((int)threadIdx.x)) + 3136)];
}


